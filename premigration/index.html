<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Мигрируй вчера</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/vs.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal slide">
			<div class="footer">
							NAUMEN, Калеми Юрий
			</div>
			<div class="slides">
				<section>
					<h2>Мигрируй вчера</h2>
					<p>Миграции данных в продуктовой разработке</p>
				</section>
				<section>
					<h2>Naumen Contact Center</h2>
					<ul>
						<li>Сервисная архитектура (~20 сервисов)</li>
						<li>Несколько сервисов работают с БД</li>
						<li>PostgreSql / Oracle</li>
						<li>Разные сервисы - разные БД (теоретически)</li>
					</ul>
					<aside class="notes">
						Как выглядит наш продукт?
						Contact Center - сервисная архитектура
						Поддерживаются PostgreSql и Oracle
						Разные сервисы могут хранить данные в разных БД
					</aside>
				</section>
				<section>
					<h2>PMS</h2>
					<ul>
						<li>Система управления проектами (PMS)</li>
						<li>Монолитное веб-приложение, Java</li>
						<li>Механизм миграций - Naumen Kernel</li>
					</ul>
				</section>
				<section>
					<h2>NCC - это продукт</h2>
					<ul>
						<li>Мажорные релизы - раз в год/полгода</li>
						<li>Минорные - каждые две недели</li>
						<li>NCC установлен на инфраструктуре клиентов</li>
						<li>Иногда нет доступа</li>
						<li>Мы мигрируем данные</li>
					</ul>
				</section>
				<section>
					<h2>Как выглядят обновления сейчас</h2>
					<ul>
						<li>Остановить приложение v1</li>
						<li>Сделать бэкап данных и настроек*</li>
						<li>Установить новую версию v2</li>
						<li>Запустить новую версию v2</li>
						<li>На старте приложения выполняется миграция</li>
						<li>Миграция закончилась - приложение запустилось</li>
					</ul>
				</section>
				<section>
					<h2>Что может пойти не так</h2>
					<ul>
						<li>Сломался один из скриптов миграции</li>
						<li>Инженер не знает как преодолеть ошибку</li>
						<li>Миграция данных выполняется слишком долго</li>
						<li>Не ясен прогресс миграции</li>
						<li>Успешная миграция - не гарантия успешного старта</li>
						<li>Нет бекапа - нет отката</li>
					</ul>
				</section>
				<section>
					<h2>Обновления</h2>
					<h3>Инженеры их боятся</h3>
				</section>
				<section>
					<h2>Проблемы бизнеса</h2>
					<h3>Долгие релизы</h3>
					<ul>
						<li>Долгая доставка</li>
						<li>Нет обратной связи</li>
						<li>Нет повторных продаж</li>
					</ul>
				</section>
				<section>
					<h2>Проблемы бизнеса</h2>
					<h3>Высокие трудозатраты обновлений</h3>
				</section>
				<section>
					<h2>Проблемы бизнеса</h2>
					<h3>Риски для клиентов</h3>
					<ul>
						<li>Невозможно обновить самостоятельно</li>
						<li>Неработающие интеграции</li>
						<li>Долгие миграции</li>
						<li>Большой простой</li>
						<li>Потеря данных</li>
					</ul>
				</section>
				<section>
					<h2>Обновления</h2>
					<h3>Их боятся все</h3>
				</section>
				<section>
					<h2>Требования бизнеса</h2>
					<ul>
						<li>Короткие релизы</li>
						<li>Универсальная процедура обновления</li>
						<li>Минимальный простой</li>
						<li>Понимание прогресса обновления</li>
						<li>Сократить трудозатраты</li>
						<li>Возможность быстрого отката/li>
						<li>Всё это реализовать - за реальные сроки</li>
					</ul>
				</section>
				<section>
					<h2>Формулировка проблемы</h2>
					<ul>
						<li>Короткие релизы -></li>
						<li>Релизов в год больше -></li>
						<li>Столько версий невозможно поддерживать -></li>
						<li>Клиентов надо обновлять часто -></li>
						<li>3-4 обновления в год для клиента -></li>
						<li>300-400 обновлений для нас</li>
					</ul>
					<aside class="notes">
						Мы (вендор) хотим осуществить переход к более коротким релизам. Значит, релизов
						 будет больше, а так как поддерживать большое количество версий невозможно,
						 то хочется говорить: «дефект исправлен в следующей версии». Т.е. минорное
						 обновление будет не 12.3.52 → 12.3.54, а 12.3 → 12.4. Таких обновлений для одного
						 клиента может быть 3-4 в год. Если клиентов около 100, то количество обновлений,
						 которые мы должны произвести в год - равно количеству дней.
						Кратко: мы хотим обновлять всех клиентов часто (=много обновлений), но клиенты и инженеры обновлений боятся
					</aside>
				</section>
				<section>
					<h2>Формулировка проблемы</h2>
					<ul>
						<li>Хотим обновлять часто</li>
						<li>Но все обновлений боятся</li>
					</ul>
				</section>
				<section>
					<h2>Задача</h2>
					<h3>Обновления не должны пугать</h3>
					<ul>
						<li>Понятный прогресс обновления</li>
						<li>Не должно быть боязни потери данных: не меняем данные</li>
						<li>Запуск новой версии приложения - максимально быстро</li>
						<li>Возможность отката</li>
					</ul>
				</section>
				<section>
					<h2>Мировой опыт</h2>
					<aside class="notes">Какие вообще есть мировые практики доставки новых версий продукта с минимальным простоем?
						В основном, все, конечно, решают только амбициозную задачу - обновление с нулевым простоем
						(ну, или только про такие задачи рассказывают в статьях и на конференциях).
						Давайте посмотрим на решение, и чему мы можем из него научиться.
					</aside>
				</section>
				<section>
					<h2>Blue Green Deployment</h2>
					TODO схемы
					<aside class="notes">Самый простой и самый распространенный способ доставки нового релиза без прерывания обсуживания.
Есть два идентичных production-окружения. Синее и зелёное.
В каждый момент времени только одно из них активно. Например, синее.
При выпуске нового релиза на зеленом окружении собирается и тестируется новая версия приложения.
Как только все тесты прошли, маршрутизатор переключается на зеленое окружение, и все запросы теперь идут к нему.

Очень простая возможность отката изменений: если что-то пошло не так, то переключаем маршрутизатор обратно на синее окружение.
После успешного обновления синее окружение очищается и становится площадкой для следующего релиза.
Таким образом дополнительно при каждом обновлении тестируется горячее резервирование.
					</aside>
				</section>
				<section>
					<h2>Blue Green Deployment</h2>
					<h3>А База данных?</h3>
					<ul>
						<li>Около 330 таблиц на все сервисы</li>
						<li>Изменения в каждом мажорном обновлении</li>
					</ul>
					<aside class="notes">
						Я думаю, со 100% уверенностью могу сказать, что пока что ни одно мажорное обновление
						не обходилось без каких-либо изменений в БД. Мы меняем схему, мы меняем данные.
					</aside>
				</section>
				<section>
					<h2>Миграция БД</h2>
					<p>Отделить изменения схемы от обновления приложения</p>
					<aside class="notes">
						Выход: разделить изменение схемы (миграции) и обновление приложения.
					</aside>
				</section>
				<section>
					<h2>Миграция БД</h2>
					<ul>
						<li>Меняем схему для поддержки v1 и v2</li>
						<li>Устанавливаем приложение v2</li>
						<li>После успешного обновления - удаляем поддержку v1</li>
					</ul>
					<aside class="notes">
					Меняем схему таким образом, чтобы обе версии приложения могли работать с этой схемой
					Устанавливаем новую версию приложения
					Когда обновление считается успешным - удаляем “остатки” старой схемы
					Звучит как-то слишком просто. Давайте взглянем на это конкретнее.
					</aside>
				</section>
				<section>
					<h2>Blue Green для БД</h2>
					TODO таблицы до и после миграции
					<aside class="notes">
						Таблица Person, была колонка Fullname, разделить на Name и Surname
					</aside>
				</section>
				<section>
					<h2>Blue Green для БД</h2>
					TODO таблицы в трех вариантах
					<aside class="notes">
						1. Добавляем новые колонки Name и Surname
						2. Приложение v2 умеет читать из всех трёх колонок и возвращает всегда корректные данные. 
							Пишет сразу в обоих форматах, так как иначе v1 не будет работать.
						3. В фоне есть какой-то процесс миграции, который переводит данные из формата v1 в формат v2
						4. Как только признаём, что миграция успешна - можно перестать писать данные в формате v1 
							(это может быть переключение какого-то конфига или новая версия приложения v3). 
							С этого момента нет отката на старую версию приложения.
						5. Удаляем колонку Fullname

						С удалением колонки могут быть некоторые проблемы, если вы используете ORM - колонку можно будет
						удалить только в той версии, где она уже не задействована в маппинге. Т.е. для удаления
						надо выпускать отдельную версию приложения.
					</aside>
				</section>
				<section>
					<h2>Преимущества</h2>
					<ul>
						<li>Изменение схемы во время работы</li>
						<li>Изменение схемы != Обновление приложения</li>
						<li>Обратная совместимость - автоматически</li>
						<li>Простой откат - автоматически</li>
					</ul>
					<aside class="notes">
						Что можно отметить, чему можно научиться?
						1. Изменение схемы происходит на “живом” приложении. Так живут многие компании, значит во многих случаях это возможно.
						2. Разделяем изменение схемы и обновление приложений. При старте приложения никакой миграции/изменения схемы не происходит. Тогда старт - быстрый.
						3. Во-первых, изменения схемы не должны нарушать обратную совместимость. В нашем текущем подходе мы бы просто удалили одну колонку, 
							создали две другие и помигрировали данные. Но если у нас одновременно работают два приложения, то нельзя удалять колонку, 
							так как она используется старой версией приложения (как именно прийти в таким изменениям, не ломающим обратную совместимость - поговорим дальше).
						4. Во-вторых, так как мы не нарушаем обратную совместимость, то у нас автоматически появляется простой способ отката - 
							мы не изменяли старые данные вообще, они не могут испортиться в результате миграции.
						5. Возможность отката зависит также от того, как мы реализуем переход на версию v2. Если версия v2 может писать данные 
							в обоих форматах, то даже после продолжительной работы на этой версии мы всё ещё можем остановить v2 
							и просто запустить v1 - нам не нужно никакое восстановление из бэкапа.
					</aside>
				</section>
				<section>
					<h2>Проблемы</h2>
					<ul>
						<li>3! версии приложения для одного обновления</li>
						<li>+ 2 изменения схемы</li>
						<br>
						<li>Как выпускать такие релизы?</li>
						<li>Как обновлять десятки/сотни клиентов?</li>
					</ul>
					<aside class="notes">
						Для одного обновления нужно две или даже три версии приложения (v2 и v3) и два изменения схемы БД. 
						Это работает в условиях сервиса, но как выпускать по две версии за один релиз? Как выполнять такое обновление у десятков клиентов?
					</aside>
				</section>
				<section>
					<h2>Миграция продукта</h2>
					<aside class="notes">
						Ок, давайте вернёмся к нашим баранам, т.е. нашему процессу, и попытаемся уменьшить количество обновлений.
					</aside>
				</section>
				<section>
					<h2>Идея #1: Фоновые миграции</h2>
					<ul>
						<li>На старте - нет миграций данных</li>
						<li>На старте - только изменение схемы</li>
						<li>Миграции в фоне после запуска</li>
						<li>V2 приложение одновременно работает с v1,v2 данными</li>
					</ul>
					<aside class="notes">
						Применим все прелести Blue Green к нашему приложению и нашему процессу.
						Основная идея: На старте приложения нет миграций, только подготовка новой схемы 
						(новые колонки, таблицы). Все миграции - в фоне после запуска. Приложение работает 
						одновременно со старыми данными и с новыми (помигрированными), причём старые данные остаются в старых колонках без изменений.
						Под словом “работает” можно понимать или “приложение умеет читать обе версии данных, 
						но пишет только в новом формате”, что проще. Или “приложение читает оба формата и 
						пишет тоже в обоих форматах, чтобы был простой откат” - что намного сложнее.
					</aside>
				</section>
				<section>
					<h2>Идея #1: Фоновые миграции</h2>
					<ul>
						<li>Пока идут миграции данные есть и v1, и v2</li>
						<li>Нельзя выполнять долгие блокирующие операции с БД</li>
						<li>Нельзя ставить NotNull пока идут миграции</li>
					</ul>
					<aside class="notes">
						Фоновые миграции выполняются во время работы новой версии приложения, но сохраняя старые данные. 
						Т.е. пока миграция не закончилась - часть данных только в старом формате, часть - в старом и новом.

						Есть блокирующие операции - например, надо проставить Not Null. Но его нельзя проставлять, 
						пока не помигрированы все данные. Такие действия выполняются после того, как отработала фоновая 
						миграция - по какой-то команде инженера/администратора в заранее оговорённое технологическое окно.
					</aside>
				</section>
				<section>
					<h2>Идея #1: Фоновые миграции</h2>
					<h3>Процесс обновления</h3>
					<ul>
						<li>Загрузка новой версии приложения</li>
						<li>Остановка старой версии, обновление</li>
						<li>Запуск новой версии, без миграций на старте</li>
						<li>Контроль выполнения фоновых миграций</li>
						<li>Выполнение "финальных" миграций через GUI в оговорённое технологическое окно</li>
						<li>Удаление устаревших колонок - в какой-то будущей версии</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Идея #1: Фоновые миграции</h2>
					<h3>Проблемы</h3>
					<ul>
						<li>legacy</li>
						<li>Поддержка двух видов данных</li>
						<li>Всё ли будет работать? Списки</li>
					</ul>
					<aside class="notes">
						1. В новой версии накапливается legacy (нужно поддерживать данные двух видов, 
						нужно оставлять старые механизмы и т.п.). А это означает увеличение стоимости внедрения новых фич.
						2. Если изменение очень большое - не очень ясно, как реализовать поддержку 
						сразу двух версий данных. У нас был такой пример: мы переделывали маппинг объектов 
						с иерархии таблиц на дискриминаторы. Как поддерживать два разных вида объектов в ORM? Создавать фиктивные классы?
						3. Списки объектов с сортировкой и фильтрацией - как они будут работать, 
						если сортировка/фильтрации затрагивают мигрируемые данные?
					</aside>
				</section>
				<section>
					<h3>Идея #1: Фоновые миграции</h3>
					<h4>Нужна изоляция кода при работе с БД</h4>
					<aside class="notes">
						Для того, чтобы приложение могло читать данные в двух форматах (и, возможно, писать данные также в двух форматах), 
						нужно чётко понимать, где приложение общается с базой данных. Т.е. В идеальном случае для каждого 
						объекта должен быть единственный DAO, который работает с базой данных. Тогда мы можем легко локализовать 
						работу с базой и поставить все нужные условия - ( if vesrion == 1 then…).
						Т.е. Нужно думать о работе с базой в том же ключе, как работают с базой микросервисы - никакой 
						другой микросервис не должен знать о способе хранения данных в БД, кроме его владельца. 
						В любом другом монолитном сервисе должны быть точно такие же правила.
						К сожалению, эта история пока не про нас.
					</aside>
				</section>
				<section>
					<h3>Какие ваши <strike>доказательства</strike> требования?</h3>
					<ul>
						<li>Минимальный простой</li>
						<li>Короткие релизы</li>
						<li>Сократить трудозатраты</li>
						<li>Реализация за приемлемое время</li>
						<li>Возможность быстрого отката</li>
					</ul>
					<aside class="notes">
						Это мы посмотрели на мировой опыт миграции на новую схему 
						без прерывания обслуживания. Но давайте вспомним наши требования?

						1. Минимальный простой - не нулевой, т.е. какой-то простой вполне допустим. На самом деле, 
						в зависимости от сервиса, это от 10 минут до получаса. А для отчётности - вплоть до нескольких часов.
						2. Короткие релизы+сократить трудозатраты: тут и минимизировать ручную работу 
						при обновлениях, и улучшить понимание прогресса обновления и универсальность процесса 
						обновления, чтобы не нужно было проходить обучение перед каждым релизом
						3. Реализация за приемлемое время - а это значит поле для торгов с бизнесом. 
						Быстро-дорого-качественно - надо что-то исключить. В нашем случае мы временно 
						вынесли за рамки задачи на текущий момент - возможность отката БД в любой момент 
						после старта без выполнения восстановления.
					</aside>
				</section>
				<section>
					<h3>Какие ваши <strike>доказательства</strike> требования?</h3>
					<ul>
						<li>Минимальный простой</li>
						<li>Короткие релизы</li>
						<li>Сократить трудозатраты</li>
						<li>Реализация за приемлемое время</li>
						<li><strike>Возможность быстрого отката</strike></li>
					</ul>
					<aside class="notes">
						3. Реализация за приемлемое время - а это значит поле для торгов с бизнесом. 
						Быстро-дорого-качественно - надо что-то исключить. В нашем случае мы временно 
						вынесли за рамки задачи на текущий момент - возможность отката БД в любой момент 
						после старта без выполнения восстановления.
					</aside>
				</section>
				<section>
					<h2>Риски</h2>
					<ul>
						<li>Поддержка 2-х версий кода и данных</li>
						<li>Частичная неработоспособность</li>
					</ul>
					<aside class="notes">
						Самые большие риски, которые мы видим:
						Поддерживать две версии кода и две версии данных в одном приложении будет слишком дорого
						Пока работают фоновые миграции, какие-то данные находятся в разных версиях - а значит, может не работать какая-то функциональность (списки с фильтрацией)
						Давайте сначала мигрировать схему и данные, а только потом обновлять приложение!
					</aside>
				</section>
				<section>
					<h2>Идея #2</h2>
					<ul>
						<li>Сначала мигрируем БД</li>
						<li>Потом обновляем!</li>
					</ul>
					<aside class="notes">
						Давайте сначала мигрировать схему и данные, а только потом обновлять приложение!
					</aside>
				</section>
				<section>
					<h2>Идея #2: Предмиграции</h2>
					<ul>
						<li>Старая версия v1 - активна</li>
						<li>Запускаем миграции v1 -> v2</li>
						<li>Останавливаем v1, запускаем v2</li>
						<li>Доделываем миграции и блокирующие операции</li>
					</ul>
					<aside class="notes">
						Основная идея: перед обновлением на новую версию запускается мигратор, 
						приложение при этом не останавливается. После окончания миграции останавливается приложение, 
						запускается новая версия, которая на старте (как сейчас) домигрирует новые или изменённые данные, 
						удаляет старые столбцы, выполняет какие-то блокирующие операции.
					</aside>
				</section>
				<section>
					<h2>Пример</h2>
					TODO
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h3>Предмигратор</h3>
					<ul>
						<li>Работает пока есть что мигрировать</li>
						<li>Должен уметь находить что мигрировать</li>
					</ul>
					<aside class="notes">
						Предмигратор работает пока есть что мигрировать. Т.е. Он должен уметь определять - а что ещё нужно помигрировать.
						Да, пока мы написали только две миграции, и нам повезло - это неизменяемые данные. Поэтому было достаточно легко определить, какие строки надо мигрировать.
					</aside>
				</section>
				<section>
					<h3>А если данные изменились?</h3>
					<ul>
						<li>Версия данных в каждой строке</li>
						<li>Триггеры</li>
					</ul>
					<aside class="notes">
						Дальше только теория, как это можно решать:
						Хранить версию данных для каждой строки. Если мы помигрировали строку на версию v2, 
						то записываем в версию v2. Если старое приложеине изменило данные, то оно записывает 
						в эту строку свою версию, т.е v1. Итого, мигратор работает пока есть строки с версией v1.
						Триггеры. Перед началом работы предмигратор создаёт триггер, который в случае изменений 
						в строке удалит новую версию данных/сбросит версию данных/куда-то сохранит информацию, что эту строку надо домигрировать
					</aside>
				</section>
				<section>
					<h3>Принципы</h3>
					<ul>
						<li>Не менять данные</li>
						<li>Не вызывать деградацию</li>
						<li>Не блокировать БД</li>
						<li>Разбить на пачки, чтобы останавливать</li>
						<li>Уметь запускаться многократно</li>
						<li>Классические - доделывают</li>
					</ul>
					<aside class="notes">
Пред-миграции выполняются во время работы старой версии приложения, поэтому не должны затрагивать старые данные, не должны
вызывать деградацию приложения. Если деградация возникает (слишком высокая нагрузка на диск/cpu/т.п.), должна быть возможность
остановить предмиграции.

  * никак не изменяем и не удаляем существующие данные
  * не выполняем блокирующих операций над БД (как минимум - блокирующих БД надолго)
  * процесс миграции должен быть разбит на пачки, для того чтобы можно было остановить этот процесс после выполнения очередной пачки (сейчас размер пачки - 1000)
  * миграции должны уметь запускаться многократно, поэтому они должны отличать новые данные от уже помигрированных (домигрировать)
  * классические миграции доделывают то, что начали предмиграции (в идеале - запускают тот же код); далее - выполняют все необходимые блокирующие операции и изменения БД
					</aside>
				</section>
				<section>
					<h3>Часть приложения или новый сервис?</h3>
					<h4>Аргументы "За часть приложения"</h4>
					<ul>
						<li>Инфраструктура проще</li>
						<li>Инженерам проще (=дешевле)</li>
						<li>Кнопка в GUI</li>
					</ul>
					<aside class="notes">
						Аргументы за часть приложения: мы не хотим усложнять инфраструктуру, 
						делать жизнь инженеров более трудной (а, следовательно, увеличивать трудозатраты). 
						Если предмиграции являются частью приложения, то инженеру/администратору достаточно 
						зайти на специальную страницу и нажать кнопку.
					</aside>
				</section>
				<section>
					<h3>Часть приложения или новый сервис?</h3>
					<h4>Аргументы "За отдельный сервис"</h4>
					<ul>
						<li>Для мажорного обновления нужно минорное</li>
						<li>В случае ошибки - минорное обновление</li>
						<li>В случае проблем - рестарт приложения</li>
					</ul>
					<aside class="notes">
						Для того, чтобы в приложении версии v1 появились предмиграции, это приложение надо обновить 
						на какую-то последнюю версию v1.123. Т.е. Перед мажорным обновлением обязательно должно присутствовать минорное.
						Если в предмиграторе есть ошибка, то для её исправления надо (а) выпустить 
						новую версию всего приложения и (б) снова выполнить обновление.
						Если предмигратор завис и не отвечает, то в случае отдельного сервиса можно его просто убить.
					</aside>
				</section>
				<section>
					<h3>Отдельный сервис</h3>
					<ul>
						<li>Один Предмигратор для всех сервисов</li>
						<li>Есть веб-интерфейс</li>
						<li>Доступен из приложения (проксируется)</li>
						<li>Для инженера/администратора: почти как часть приложения</li>
					</ul>
					<aside class="notes">
						В итоге мы решили, что предмигратор - это отдельный сервис. К тому же, 
						миграции могут понадобиться для большого количества сервисов. 
						И логично не писать для каждого из них предмигратор, а использовать один на всех.

						Для того, чтобы снизить неудобства инженера/администратора:
						У предмигратора есть свой веб-интерфейс, где можно увидеть предполагаемый 
						список миграций. Можно их запускать/останавливать и просматривать статистику.
						Веб-интерфейс предмигратора показывается внутри веб-приложения (запросы проксируются). 
						Таким образом для инженера/администратора это выглядит как часть веб-приложения.
					</aside>
				</section>
				<section>
					<h3>Как выглядит сервис?</h3>
					<ul>
						<li>Java, Spring boot</li>
						<li>Есть web, rest, jmx</li>
						<li>Можно остановить в процессе</li>
						<li>Можно продолжить выполнеие</li>
						TODO
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Идея #1: Фоновые миграции</h2>
					<h3>Процесс обновления</h3>
					<ul>
						<li>Загрузка новой версии предмигратора</li>
						<li>Запуск предмиграций</li>
						<li>Возможны повторные запуски предмиграций</li>
						<li>Загрузка новой версии приложения</li>
						<li>Остановка старой версии приложения</li>
						<li>Запуск новой версии приложения</li>
						<li>Во время старта: домиграция и блокирующие изменения</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>А что с разработчиками и тестовыми стендами?</h3>
					<aside class="notes">
						Наши тестовые стенды обновляются на новую версию автоматически каждую ночь или несколько раз в день вручную. 
						У разработчиков также есть свои стенды на виртуальных машинах.
						Процесс выглядит слишком сложно!
					</aside>
				</section>
				<section>
					<h3>А что с разработчиками и тестовыми стендами?</h3>
					<ul>
						<li>Возможно обновление без предмигратора</li>
					</ul>
					<aside class="notes">
						Решение следующее: если не было запуска предмигратора, то при старте будет выполнена полноценная миграция, т.е. как и раньше.
					</aside>
				</section>
				<section>
					<h3>Будет две версии миграций?</h3>
					<ul>
						<li>В общем случае - да. Для PMS - нет</li>
						<li>PMS - состоит из модулей</li>
						<li>Модуль для миграций</li>
						<li>Его используют PMS и Предмигратор</li>
					</ul>
					<aside class="notes">
						Будет две версии миграций?
						Для предмигратора и для классических миграций?
						В общем случае (для любого абстрактного сервиса) - да.

						Но для нашего приложения у нас используется общий код миграций. Благодаря тому, что у нас модульная структура, код с миграциями выделен в отделный модуль. От которого зависит и предмигратор, и OPMS.

						При запуске “классической” миграции происходит запуск кода из этого модуля.

						В итоге мы можем быть уверены, что мы выполняем одни и те же изменения. И запуск классической миграции - это просто как очередной и последний запуск предмигратора.

					</aside>
				</section>
				<section>
					<h3>Покажи миграции!</h3>
					<ul>
						<li></li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что можно делать в базе?</h3>
					<ul>
						<li></li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<ul>
						<li></li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>А минусы?</h3>
					<ul>
						<li>Много места в БД</li>
						<li>Нет отката после запуска</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Возможность отката</h3>
					<h4>теоретическая</h4>
					<ul>
						<li>Много места в БД</li>
						<li>Нет отката после запуска</li>
					</ul>
					<aside class="notes">
						После того, как запущена новая версия приложения, выполняются различные изменения в схеме данных, которые могут привести к невозможности запуска старой версии.
						Самый банальный пример - удаление столбца, добавление ограничения Not Null.

						Можно договориться и не делать такие изменения на старте системы, тогда возможность отката будет сохранена. Но с тем же Not Null - не ясно, когда мы сможем его сделать? Сколько будет жить приложение без этого ограничения?

						Но после того как приложение запускается и пользователи начинают работу, они начинают записывать данные в новые таблицы и колонки. И откат не возможен, потому что данные в старых таблицах становятся неконсистентные.

						Единственный выход - писать в двух форматах. См. все предыдущие ограничения и задачи, которые стоят перед нами и нашим приложением.
						Надеюсь, мы сможем научиться работать по такой схеме.
					</aside>
				</section>
				<section>
					<h3>Сопутствующие приобретения</h3>
					<ul>
						<li>Простое тестирование миграций во время разработки</li>
						<li>Запуск на любом стенде</li>
						<li>Запуск на тестовой базе клиентов</li>
						<li>Мигрировать можно и днём</li>
					</ul>
					<aside class="notes">
						Можно тестировать на любом тестовом стенде - данные не портятся.
						Можно тестировать прямо в процессе разработки на любом тестовом стенде клиента - 
						и находить проблемные данные, которые сломают миграцию. И учесть это. А также проверить примерное время выполнения.
						Если выполнять вообще все миграции через предмигратор, то не нужны тестовые миграции!
					</aside>
				</section>
				<section>
					<h3>Результат</h3>
					<ul>
						<li>На тестовом стенде клиента</li>
						<li>Нашли 2 ошибки - исправили до выпуска версии</li>
						<li>Миграции проходят за 14 часов</li>
						<li>Одна идёт ~14 часов, другая - 30 секунд</li>
					</ul>
					<aside class="notes">
						Мы выполнили предмиграцию на тестовой базе самого большого клиента.
						Нашли 2 ошибки, из-за которых миграции не работали. Исправили их ещё до выпуска версии.
						Миграции проходят примерно 14 часов (без нагрузки на базу, конечно). У нас всего две миграции: одна шла 14 часов, другая - 30 секунд.
					</aside>
				</section>

				<section>
					<h2>Конец</h2>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				// Shows the slide number using default formatting
				slideNumber: true,
				controls: false,
				center: true,
				transition: 'slide',
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
