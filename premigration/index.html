<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Мигрируй вчера</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/vs.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal slide">
			<div class="footer">
							NAUMEN, Калеми Юрий
			</div>
			<div class="slides">
				<section>
					<h2>Мигрируй вчера</h2>
					<p>Миграции данных в продуктовой разработке</p>
				</section>
				<section>
					<h2>Naumen Contact Center</h2>
					<ul>
						<li>Сервисная архитектура (~20 сервисов)</li>
						<li>Несколько сервисов работают с БД</li>
						<li>PostgreSql / Oracle</li>
						<li>Разные сервисы - разные БД (теоретически)</li>
					</ul>
					<aside class="notes">
						Как выглядит наш продукт?
						Contact Center - сервисная архитектура
						Поддерживаются PostgreSql и Oracle
						Разные сервисы могут хранить данные в разных БД
					</aside>
				</section>
				<section>
					<h2>PMS</h2>
					<ul>
						<li>Система управления проектами (PMS)</li>
						<li>Монолитное веб-приложение, Java</li>
						<li>Механизм миграций - Naumen Kernel</li>
					</ul>
				</section>
				<section>
					<h2>NCC - это продукт</h2>
					<ul>
						<li>Мажорные релизы - раз в год/полгода</li>
						<li>Минорные - каждые две недели</li>
						<li>NCC установлен на инфраструктуре клиентов</li>
						<li>Иногда нет доступа</li>
						<li>Мы мигрируем данные</li>
					</ul>
				</section>
				<section>
					<h3>Как выглядят обновления сейчас<h3>
					<img data-src="img/migr.svg" width="100%"  style="border:0"/>
				</section>
				<section>
					<h3>Что может пойти не так</h3>
					<img data-src="img/long.svg" width="100%"  style="border:0"/>
				</section>
				<section>
					<h3>Что может пойти не так</h3>
					<img data-src="img/error.svg" width="100%"  style="border:0"/>
				</section>
				<section>
					<h2>Мировой опыт</h2>
					<aside class="notes">Какие вообще есть мировые практики доставки новых версий продукта с минимальным простоем?
						В основном, все, конечно, решают только амбициозную задачу - обновление с нулевым простоем
						(ну, или только про такие задачи рассказывают в статьях и на конференциях).
						Давайте посмотрим на решение, и чему мы можем из него научиться.
					</aside>
				</section>
				<section>
					<h3>Blue Green Deployment</h3>
					<img data-src="img/green.svg" width="100%"  style="border:0"/>
					<aside class="notes">Самый простой и самый распространенный способ доставки нового релиза без прерывания обсуживания.
Есть два идентичных production-окружения. Синее и зелёное.
В каждый момент времени только одно из них активно. Например, синее.
При выпуске нового релиза на зеленом окружении собирается и тестируется новая версия приложения.
Как только все тесты прошли, маршрутизатор переключается на зеленое окружение, и все запросы теперь идут к нему.

Очень простая возможность отката изменений: если что-то пошло не так, то переключаем маршрутизатор обратно на синее окружение.
После успешного обновления синее окружение очищается и становится площадкой для следующего релиза.
Таким образом дополнительно при каждом обновлении тестируется горячее резервирование.
					</aside>
				</section>
				<section>
					<h3>Blue Green Deployment</h3>
					<img data-src="img/blue.svg" width="100%"  style="border:0"/>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Blue Green для БД</h3>
					<img data-src="img/bg_migr.svg" width="100%"  style="border:0"/>
					<aside class="notes">
					Меняем схему для поддержки v1 и v2
					Устанавливаем приложение v2
					После успешного обновления - удаляем поддержку v1


					Меняем схему таким образом, чтобы обе версии приложения могли работать с этой схемой
					Устанавливаем новую версию приложения
					Когда обновление считается успешным - удаляем “остатки” старой схемы
					Звучит как-то слишком просто. Давайте взглянем на это конкретнее.


						1. Добавляем новые колонки Name и Surname
						2. Приложение v2 умеет читать из всех трёх колонок и возвращает всегда корректные данные.
							Пишет сразу в обоих форматах, так как иначе v1 не будет работать.
						3. В фоне есть какой-то процесс миграции, который переводит данные из формата v1 в формат v2
						4. Как только признаём, что миграция успешна - можно перестать писать данные в формате v1
							(это может быть переключение какого-то конфига или новая версия приложения v3).
							С этого момента нет отката на старую версию приложения.
						5. Удаляем колонку Fullname

						С удалением колонки могут быть некоторые проблемы, если вы используете ORM - колонку можно будет
						удалить только в той версии, где она уже не задействована в маппинге. Т.е. для удаления
						надо выпускать отдельную версию приложения.
					</aside>
				</section>
				<section>
					<h3>Преимущества</h3>
					<ul>
						<li>Изменение схемы во время работы</li>
						<li>Изменение схемы != Обновление приложения</li>
						<li>Обратная совместимость - автоматически</li>
						<li>Простой откат - автоматически</li>
					</ul>
					<aside class="notes">
						Что можно отметить, чему можно научиться?
						1. Изменение схемы происходит на “живом” приложении. Так живут многие компании, значит во многих случаях это возможно.
						2. Разделяем изменение схемы и обновление приложений. При старте приложения никакой миграции/изменения схемы не происходит. Тогда старт - быстрый.
						3. Во-первых, изменения схемы не должны нарушать обратную совместимость. В нашем текущем подходе мы бы просто удалили одну колонку,
							создали две другие и помигрировали данные. Но если у нас одновременно работают два приложения, то нельзя удалять колонку,
							так как она используется старой версией приложения (как именно прийти в таким изменениям, не ломающим обратную совместимость - поговорим дальше).
						4. Во-вторых, так как мы не нарушаем обратную совместимость, то у нас автоматически появляется простой способ отката -
							мы не изменяли старые данные вообще, они не могут испортиться в результате миграции.
						5. Возможность отката зависит также от того, как мы реализуем переход на версию v2. Если версия v2 может писать данные
							в обоих форматах, то даже после продолжительной работы на этой версии мы всё ещё можем остановить v2
							и просто запустить v1 - нам не нужно никакое восстановление из бэкапа.
					</aside>
				</section>
				<section>
					<h3>Проблемы</h3>
					<ul>
						<li>3! версии приложения для одного обновления</li>
						<li>+ 2 изменения схемы</li>
						<br>
						<li>Как выпускать такие релизы?</li>
						<li>Как обновлять десятки/сотни клиентов?</li>
					</ul>
					<aside class="notes">
						Для одного обновления нужно две или даже три версии приложения (v2 и v3) и два изменения схемы БД.
						Это работает в условиях сервиса, но как выпускать по две версии за один релиз? Как выполнять такое обновление у десятков клиентов?
					</aside>
				</section>
				<section>
					<h2>Миграция продукта</h2>
					<aside class="notes">
						Ок, давайте вернёмся к нашим баранам, т.е. нашему процессу, и попытаемся уменьшить количество обновлений.
					</aside>
				</section>
				<section>
					<h3>Идея #1: Фоновые миграции</h3>
					<img data-src="img/background.svg" width="100%"  style="border:0"/>
					<aside class="notes">
						Применим все прелести Blue Green к нашему приложению и нашему процессу.
						Основная идея: На старте приложения нет миграций, только подготовка новой схемы
						(новые колонки, таблицы). Все миграции - в фоне после запуска. Приложение работает
						одновременно со старыми данными и с новыми (помигрированными), причём старые данные остаются в старых колонках без изменений.
						Под словом “работает” можно понимать или “приложение умеет читать обе версии данных,
						но пишет только в новом формате”, что проще. Или “приложение читает оба формата и
						пишет тоже в обоих форматах, чтобы был простой откат” - что намного сложнее.
					</aside>
				</section>
				<section>
					<h2>Идея #1: Фоновые миграции</h2>
					<ul>
						<li>Пока идут миграции данные есть и v1, и v2</li>
						<li>Нельзя выполнять долгие блокирующие операции с БД</li>
						<li>Нельзя ставить NotNull пока идут миграции</li>
					</ul>
					<aside class="notes">
						Фоновые миграции выполняются во время работы новой версии приложения, но сохраняя старые данные.
						Т.е. пока миграция не закончилась - часть данных только в старом формате, часть - в старом и новом.

						Есть блокирующие операции - например, надо проставить Not Null. Но его нельзя проставлять,
						пока не помигрированы все данные. Такие действия выполняются после того, как отработала фоновая
						миграция - по какой-то команде инженера/администратора в заранее оговорённое технологическое окно.
					</aside>
				</section>
				<section>
					<h2>Идея #1: Фоновые миграции</h2>
					<h3>Проблемы</h3>
					<ul>
						<li>legacy</li>
						<li>Поддержка двух видов данных</li>
						<li>Всё ли будет работать? Списки</li>
					</ul>
					<aside class="notes">
						1. В новой версии накапливается legacy (нужно поддерживать данные двух видов,
						нужно оставлять старые механизмы и т.п.). А это означает увеличение стоимости внедрения новых фич.
						2. Если изменение очень большое - не очень ясно, как реализовать поддержку
						сразу двух версий данных. У нас был такой пример: мы переделывали маппинг объектов
						с иерархии таблиц на дискриминаторы. Как поддерживать два разных вида объектов в ORM? Создавать фиктивные классы?
						3. Списки объектов с сортировкой и фильтрацией - как они будут работать,
						если сортировка/фильтрации затрагивают мигрируемые данные?
					</aside>
				</section>
				<section>
					<h2>Риски</h2>
					<ul>
						<li>Поддержка 2-х версий кода и данных</li>
						<li>Частичная неработоспособность</li>
					</ul>
					<aside class="notes">
						Самые большие риски, которые мы видим:
						Поддерживать две версии кода и две версии данных в одном приложении будет слишком дорого
						Пока работают фоновые миграции, какие-то данные находятся в разных версиях - а значит, может не работать какая-то функциональность (списки с фильтрацией)
						Давайте сначала мигрировать схему и данные, а только потом обновлять приложение!
					</aside>
				</section>
				<section>
					<h2>Идея #2</h2>
					<ul>
						<li>Сначала мигрируем БД</li>
						<li>Потом обновляем!</li>
					</ul>
					<aside class="notes">
						Давайте сначала мигрировать схему и данные, а только потом обновлять приложение!
					</aside>
				</section>
				<section>
					<h2>Идея #2: Предмиграции</h2>
					<img data-src="img/premigr.svg" width="100%"  style="border:0"/>
					<aside class="notes">
						Основная идея: перед обновлением на новую версию запускается мигратор,
						приложение при этом не останавливается. После окончания миграции останавливается приложение,
						запускается новая версия, которая на старте (как сейчас) домигрирует новые или изменённые данные,
						удаляет старые столбцы, выполняет какие-то блокирующие операции.
					</aside>
				</section>
				<section>
					<h2>Пример</h2>
					<img data-src="img/meta.png" style="border:0"/>
					<img data-src="img/newcols.png" style="border:0"/>
					<aside class="notes">
					<li>Создаем 4 новых колонки</li>
					<li>Мигрируем пока есть пустые значения в колонках</li>
					<li>Пачками обновляем значения</li>
					<li>Останавливаем старое приложение</li>
					<li>Запускаем новое</li>
					<li>На старте ещё раз мигрируем пустые колонки</li>
					<li>Удаляем колонку metadata</li>
					</aside>
				</section>
				<section>
					<h3>Принципы</h3>
					<ul>
						<li>Не менять данные</li>
						<li>Не вызывать деградацию</li>
						<li>Не блокировать БД</li>
						<li>Разбить на пачки, чтобы останавливать</li>
						<li>Уметь запускаться многократно</li>
						<li>Классические - доделывают</li>
					</ul>
					<aside class="notes">
Пред-миграции выполняются во время работы старой версии приложения, поэтому не должны затрагивать старые данные, не должны
вызывать деградацию приложения. Если деградация возникает (слишком высокая нагрузка на диск/cpu/т.п.), должна быть возможность
остановить предмиграции.

  * никак не изменяем и не удаляем существующие данные
  * не выполняем блокирующих операций над БД (как минимум - блокирующих БД надолго)
  * процесс миграции должен быть разбит на пачки, для того чтобы можно было остановить этот процесс после выполнения очередной пачки (сейчас размер пачки - 1000)
  * миграции должны уметь запускаться многократно, поэтому они должны отличать новые данные от уже помигрированных (домигрировать)
  * классические миграции доделывают то, что начали предмиграции (в идеале - запускают тот же код); далее - выполняют все необходимые блокирующие операции и изменения БД
					</aside>
				</section>
				<section>
					<h3>Часть приложения или новый сервис?</h3>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Часть приложения или новый сервис?</h3>
					<h4>Аргументы "За часть приложения"</h4>
					<ul>
						<li>Инфраструктура проще</li>
						<li>Инженерам проще (=дешевле)</li>
						<li>Кнопка в GUI</li>
					</ul>
					<aside class="notes">
						Аргументы за часть приложения: мы не хотим усложнять инфраструктуру,
						делать жизнь инженеров более трудной (а, следовательно, увеличивать трудозатраты).
						Если предмиграции являются частью приложения, то инженеру/администратору достаточно
						зайти на специальную страницу и нажать кнопку.
					</aside>
				</section>
				<section>
					<h3>Часть приложения или новый сервис?</h3>
					<h4>Аргументы "За отдельный сервис"</h4>
					<ul>
						<li>Для мажорного обновления нужно минорное</li>
						<li>В случае ошибки - минорное обновление</li>
						<li>В случае проблем - рестарт приложения</li>
					</ul>
					<aside class="notes">
						Для того, чтобы в приложении версии v1 появились предмиграции, это приложение надо обновить
						на какую-то последнюю версию v1.123. Т.е. Перед мажорным обновлением обязательно должно присутствовать минорное.
						Если в предмиграторе есть ошибка, то для её исправления надо (а) выпустить
						новую версию всего приложения и (б) снова выполнить обновление.
						Если предмигратор завис и не отвечает, то в случае отдельного сервиса можно его просто убить.
					</aside>
				</section>
				<section>
					<h3>Отдельный сервис</h3>
					<ul>
						<li>Один Предмигратор для всех сервисов</li>
						<li>Есть веб-интерфейс</li>
						<li>Доступен из приложения (проксируется)</li>
						<li>Для инженера/администратора: почти как часть приложения</li>
					</ul>
					<aside class="notes">
						В итоге мы решили, что предмигратор - это отдельный сервис. К тому же,
						миграции могут понадобиться для большого количества сервисов.
						И логично не писать для каждого из них предмигратор, а использовать один на всех.

						Для того, чтобы снизить неудобства инженера/администратора:
						У предмигратора есть свой веб-интерфейс, где можно увидеть предполагаемый
						список миграций. Можно их запускать/останавливать и просматривать статистику.
						Веб-интерфейс предмигратора показывается внутри веб-приложения (запросы проксируются).
						Таким образом для инженера/администратора это выглядит как часть веб-приложения.
					</aside>
				</section>
				<section>
					<h3>Как выглядит сервис?</h3>
					<ul>
						<li>Java, Spring boot</li>
						<li>Web, REST, JMX</li>
						<li>Можно остановить в процессе</li>
						<li>Можно продолжить выполнение</li>
						<li>Проверка версии мигрируемой базы</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Будет две версии миграций?</h3>
					<ul>
						<li>В общем случае - да. Для PMS - нет</li>
						<li>PMS - состоит из модулей</li>
						<li>Модуль для миграций</li>
						<li>Его используют PMS и Предмигратор</li>
					</ul>
					<aside class="notes">
						Будет две версии миграций?
						Для предмигратора и для классических миграций?
						В общем случае (для любого абстрактного сервиса) - да.

						Но для нашего приложения у нас используется общий код миграций. Благодаря тому, что у нас модульная структура, код с миграциями выделен в отделный модуль. От которого зависит и предмигратор, и OPMS.

						При запуске “классической” миграции происходит запуск кода из этого модуля.

						В итоге мы можем быть уверены, что мы выполняем одни и те же изменения. И запуск классической миграции - это просто как очередной и последний запуск предмигратора.

					</aside>
				</section>
				<section>
					<h3>Что можно делать в базе?</h3>
					<ul>
						<li>Добавление колонки</li>
						<li>Удаление колонки (PG)</li>
						<li>Создание индекса с флагом CONCURRENTLY (PG) / ONILNE (ORA)</li>
						<li>Удаление ограничения</li>
						<li>Добавить дефолтное значение в существующую колонку</li>
						<li>ORA: DBMS_REDEFINITION</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<h4>Добавлять индекс</h4>
					<ul>
						<li>Делай CONCURRENTLY/ONLINE</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<h4>Менять тип/имя колонки</h4>
					<ul>
						<li>Создай новую колонку</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<h4>Добавлять новую колонку с дефолтным значением</h4>
					<ul>
						<li>Добавить новую колонку</li>
						<li>Добавить дефолтное значение</li>
						<li>Заполнить колонку дефолтным значением</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе?</h3>
					<h4>Добавлять новую колонку NOT NULL</h4>
					<ul>
						<li>Создать новую таблицу</li>
						<li>Добавить NOT NULL колонку</li>
						<li>Писать в обе таблицы</li>
						<li>Скопировать данные...</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе? (PG?)</h3>
					<h4>Добавлять новую колонку UNIQUE</h4>
					<ul>
						<li>Добавить колонку</li>
						<li>Добавить уникальный индекс (concurrently)</li>
						<li>Добавить ограничение на таблицу</li>
						<li>UNIQUE USING INDEX</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе? (PG?)</h3>
					<h4>VACUUM FULL</h4>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Что нельзя делать в базе? (PG?)</h3>
					<h4>ALTER TABLE</h4>
					<p>Даже на пустых таблицах, но имеющих FK</p>
<pre><code data-trim data-noescape class="language-sql">
SELECT DISTINCT(email) FROM tbl_parent;

ALTER TABLE tbl_child ADD CONSTRAINT parent_fk
FOREIGN KEY (parent_id) REFERENCES tbl_parent NOT VALID;

SELECT * FROM parent WHERE id = 123;
</code></pre>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>А минусы?</h3>
					<ul>
						<li>Много места в БД</li>
						<li>Нет отката после запуска</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Возможность отката</h3>
					<h4>теоретическая</h4>
					<aside class="notes">
						После того, как запущена новая версия приложения, выполняются различные изменения в схеме данных, которые могут привести к невозможности запуска старой версии.
						Самый банальный пример - удаление столбца, добавление ограничения Not Null.

						Можно договориться и не делать такие изменения на старте системы, тогда возможность отката будет сохранена. Но с тем же Not Null - не ясно, когда мы сможем его сделать? Сколько будет жить приложение без этого ограничения?

						Но после того как приложение запускается и пользователи начинают работу, они начинают записывать данные в новые таблицы и колонки. И откат не возможен, потому что данные в старых таблицах становятся неконсистентные.

						Единственный выход - писать в двух форматах. См. все предыдущие ограничения и задачи, которые стоят перед нами и нашим приложением.
						Надеюсь, мы сможем научиться работать по такой схеме.
					</aside>
				</section>
				<section>
					<h3>Сопутствующие приобретения</h3>
					<ul>
						<li>Простое тестирование миграций во время разработки</li>
						<li>Запуск на любом стенде</li>
						<li>Запуск на тестовой базе клиентов</li>
						<li>Мигрировать можно и днём</li>
					</ul>
					<aside class="notes">
						Можно тестировать на любом тестовом стенде - данные не портятся.
						Можно тестировать прямо в процессе разработки на любом тестовом стенде клиента -
						и находить проблемные данные, которые сломают миграцию. И учесть это. А также проверить примерное время выполнения.
						Если выполнять вообще все миграции через предмигратор, то не нужны тестовые миграции!
					</aside>
				</section>
				<section>
					<h3>Результат</h3>
					<ul>
						<li>На тестовом стенде клиента</li>
						<li>Нашли 2 ошибки - исправили до выпуска версии</li>
						<li>Миграции проходят за 14 часов</li>
						<li>Одна идёт ~14 часов, другая - 30 секунд</li>
					</ul>
					<aside class="notes">
						Мы выполнили предмиграцию на тестовой базе самого большого клиента.
						Нашли 2 ошибки, из-за которых миграции не работали. Исправили их ещё до выпуска версии.
						Миграции проходят примерно 14 часов (без нагрузки на базу, конечно). У нас всего две миграции: одна шла 14 часов, другая - 30 секунд.
					</aside>
				</section>

				<section>
					<h2>Конец</h2>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				// Shows the slide number using default formatting
				slideNumber: true,
				controls: false,
				center: true,
				transition: 'slide',
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
